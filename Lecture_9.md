**《信息论》第9讲 课堂笔记：汉明码详解、编译码及线性码构造**

**〇、引言**

在上一讲（第8讲）中，我们初步探讨了信道编码的基本概念，包括其动机、重复码示例、核心的可靠性与效率权衡，以及重要的理论界限——球堆积界和吉尔伯特-瓦尔沙莫夫界。课程最后引入了汉明码作为结构化码的例子，通过其校验矩阵 $H$ 来定义。本节课将继续深入探讨汉明码，特别是 $(7,4)$ 汉明码，详细解析其高效的代数编译码方法。我们还将回顾线性码的一般参数，并讨论如何通过缩短和扩展等方法从已知码构造新码。

---

**I. 核心概念回顾与详解 (续)**

1.  **(7,4) 汉明码 (Hamming Code) 再探**
    *   **(回顾 Part 1 & Part 2)** 我们已经知道 $(7,4)$ 汉明码是一个**线性分组码 (Linear Block Code)**。
    *   **校验矩阵 (Parity Check Matrix) $H$**:
        其码字集合 $C$ 由校验矩阵 $H$ 的**零空间 (Null Space)** 定义。一个常用的 $(7,4)$ 汉明码的校验矩阵 $H$ 如下：
        $$ H = \begin{pmatrix} 0 & 0 & 0 & 1 & 1 & 1 & 1 \\ 0 & 1 & 1 & 0 & 0 & 1 & 1 \\ 1 & 0 & 1 & 0 & 1 & 0 & 1 \end{pmatrix}_{3 \times 7} $$
        这个矩阵的列是数字 1 到 7 的所有非零3比特二进制串的一种特定排列（例如，按字典序或按数值顺序的 $h_1=(001)^T, h_2=(010)^T, \dots, h_7=(111)^T$ 进行列置换可得到多种等价的 $H$ 矩阵）。矩阵运算在伽罗瓦域 $GF(2)$ 上进行。
    *   **码字集合 $C$**:
        $$ C = \text{Null}(H) = \{x \in \{0,1\}^7 \mid Hx = \mathbf{0} \} $$
        其中 $x$ 是一个 $7 \times 1$ 的列向量码字，$\mathbf{0}$ 是一个 $3 \times 1$ 的零向量。
    *   **参数**:
        *   码长 (length) $n=7$。
        *   维数 (dimension) $k=4$。因为 $H$ 是一个 $3 \times 7$ 矩阵，其行向量线性无关，故 $\text{rank}(H)=3$。根据线性代数，其零空间的维数为 $k = n - \text{rank}(H) = 7 - 3 = 4$。因此，存在 $2^k = 2^4 = 16$ 个不同的码字。这对应于 $2^4$ 个不同的4比特信息。
    *   **最小汉明距离 (Minimum Hamming Distance) $d_{min}$**:
        *   对于线性码，最小汉明距离 $d_{min}$ 等于码中非零码字的最小汉明重量 $w_{min}$。
        *   即 $d_{min} = \min \{ w_H(x) \mid x \in C, x \neq \mathbf{0} \}$。
        *   对于上述 $H$ 矩阵，任何单独一列非零，任何两列线性无关（因为它们都不同）。但是存在三列是线性相关的（例如，上述 $H$ 矩阵的第1、2、3列 $(001)^T, (010)^T, (011)^T$ 相加为 $\mathbf{0}$）。这意味着存在重量为3的码字（例如 $x=(1110000)^T$ 是一个码字，如果 $H$ 的列按此顺序排列）。因此，
            板书: 对于 $x_i, x_j \in \text{Null}(H)$, $d_H(x_i, x_j) \ge 3$
            板书: $Hx_k = \mathbf{0} \implies ||x_k||_1 \ge 3$ (这里 $||x_k||_1$ 即 $w_H(x_k)$)
            所以，$(7,4)$ 汉明码的 $d_{min} = 3$。
    *   **纠错能力**:
        由于 $d_{min} = 2t+1$，对于 $d_{min}=3$，可得 $t=1$。该码能纠正任意单个比特的错误。
    *   **完美码 (Perfect Code)**:
        $(7,4)$ 汉明码是一个完美码，它满足**球堆积界限 (Sphere Packing Bound)** 的等号。
        球堆积界限公式为：$M \sum_{i=0}^{t} \binom{n}{i} \le 2^n$，其中 $M=2^k$ 是码字数量。
        对于 $(7,4)$ 汉明码，$n=7, k=4 \Rightarrow M=2^4=16, t=1$:
        $$ 2^4 \left( \binom{7}{0} + \binom{7}{1} \right) = 16 \cdot (1+7) = 16 \cdot 8 = 128 $$
        而 $2^n = 2^7 = 128$。
        因此 $128 = 128$，等号成立。
        板书: For Hamming (7,4) code: length $n=7$, dimension $k=4$.
        $$ \frac{2^7}{\sum_{i=0}^{1} \binom{7}{i}} = \frac{2^7}{1+7} = \frac{128}{8} = 16 = 2^4 $$
        这是一个完美码 (Perfect code)，满足 Sphere Packing Bound Equality.

---

**II. (7,4) 汉明码的高效编译码**

1.  **高效解码 (Efficient Decoding) - 纠正1比特错误 (源自 Part 2 笔记)**
    *   **解码目标**: 当发送码字 $C_i$ 经过信道后可能带有噪声，接收端收到序列 $x$。解码的目标是从 $x$ 恢复出原始的 $C_i$。
        板书示意: $C_i \xrightarrow{\text{noise}} x \xrightarrow{\text{decode}} C_i$
    *   **纠错能力范围**: 设计目标是能够正确纠正**至多1个比特**的错误。
        板书: `(correct 1-bit error)`
        即如果 $d_H(x, C_i) \le 1 \text{ bit}$，解码算法应能成功恢复 $C_i$。
    *   **解码核心思想**: 利用校验矩阵 $H$ 计算接收序列 $x$ 的**校验和 (Syndrome)** $S = Hx$。
    *   **解码步骤与原理**:
        1.  计算校验和 $S = Hx$。
        2.  分析校验和 $S$:
            *   **情况一: $S = \mathbf{0}$ (零向量)**
                板书: $Hx = \mathbf{0} \implies x \in \text{Null}(H)$
                如果 $Hx = \mathbf{0}$，意味着 $x$ 本身就是一个合法的码字。假设没有错误发生（或发生的错误恰好将一个码字变成了另一个码字，但由于 $d_{min}=3$ 且我们假设最多1比特错误，这种情况不会与单比特错误混淆）。解码结果就是 $x$ 本身。
                板书流程: $x \xrightarrow{\text{decode}} C_i \quad (\text{if } Hx=\mathbf{0}, \text{ then } x=C_i)$

            *   **情况二: $S \ne \mathbf{0}$**
                板书: $Hx \ne \mathbf{0}$
                如果 $Hx \ne \mathbf{0}$，意味着 $x$ 不是一个合法的码字，传输过程中发生了错误。
                假设发生了1个比特的错误，错误发生在第 $j$ 个位置。那么接收到的 $x$ 可以表示为原始码字 $C_i$ 加上一个错误向量 $e_j$（$e_j$ 是一个在第 $j$ 位为1，其余位为0的向量）。
                板书: $x = C_i + e_j$
                计算 $Hx$:
                $$ Hx = H(C_i + e_j) = HC_i + He_j $$
                因为 $C_i$ 是码字，$HC_i = \mathbf{0}$。所以：
                $$ Hx = \mathbf{0} + He_j = He_j $$
                而 $He_j$ 正好是校验矩阵 $H$ 的第 $j$ 列，记为 $h_j$。
                板书: $Hx = He_j = h_j \quad \text{(j-th column of H)}$
                因此，如果计算得到的 $S = Hx$ 等于校验矩阵 $H$ 的第 $j$ 列 $h_j$，那么我们就知道错误发生在 $x$ 的第 $j$ 个比特。
                纠正方法：将 $x$ 的第 $j$ 个比特翻转 (0变1，1变0) 即可得到原始码字 $C_i$。
                板书流程:
                If $Hx = h_j \ne \mathbf{0}$
                then error is at j-th bit.
                $x \xrightarrow{\text{flip j-th bit}} C_i$

                **特别说明**: 如果校验矩阵 $H$ 的各列 $h_j$ 被特意排列成特定顺序，例如 $h_j$ 是数字 $j$ 的二进制表示 (例如，第1列是 $(001)^T$，第2列是 $(010)^T$，第3列是 $(011)^T$ 等)，那么计算得到的校验和 $S=(s_1s_2s_3)^T$ 的二进制值就直接指明了错误位置的序号。例如，如果 $S=(011)^T_2 = 3_{10}$，则第3位出错。这种 $H$ 的列的特定排列使得解码非常直观和高效。

    *   **解码算法总结**:
        1.  接收到 $x$。
        2.  计算校验和 $S = Hx$。
        3.  如果 $S = \mathbf{0}$，则解码输出为 $x$。
        4.  如果 $S \ne \mathbf{0}$，则在校验矩阵 $H$ 中找到与 $S$ 相同的列 $h_j$。错误发生在第 $j$ 个比特，将 $x$ 的第 $j$ 个比特翻转后输出。如果 $H$ 的列按上述特定顺序排列，则 $S$ 的值直接指示 $j$。
    *   **与最近邻解码的比较**: 这种基于校验和的解码方法（一次矩阵向量乘法和一次查表/比较）远比遍历所有 $2^k=16$ 个码字来寻找最近邻码字要高效得多。

2.  **高效编码 (Efficient Encoding) - 基于生成矩阵 (源自 Part 2 & Part 3 笔记)**
    *   **编码目标**: 将一个 $k$ 比特的信息 $m \in \{0,1\}^k$ 映射到一个 $n$ 比特码字 $c \in C = \text{Null}(H) \subseteq \{0,1\}^n$。
        板书: `Encode:`
               $\{0,1\}^k \xrightarrow{G} \{0,1\}^n$
               $m \longrightarrow c \in \text{Null}(H)$
    *   **生成矩阵 (Generator Matrix) $G$**:
        对于线性码，编码过程可以通过一个生成矩阵 $G$ 来实现。$G$ 是一个 $n \times k$ 的矩阵（假设信息 $m$ 是 $k \times 1$ 列向量，码字 $c$ 是 $n \times 1$ 列向量），其列向量构成了 $\text{Null}(H)$ 的一组基。
        编码操作即为：$c = Gm$。
        由于 $c \in \text{Null}(H)$，所以必须满足 $Hc = \mathbf{0}$。
        因此，$H(Gm) = (HG)m = \mathbf{0}$。为了使这个等式对所有信息向量 $m$ 都成立，必须有：
        板书: $$ HG = \mathbf{0} $$
        ($\mathbf{0}$ 是一个 $(n-k) \times k$ 的零矩阵)。

    *   **系统码 (Systematic Code)**:
        一种方便的编码形式是系统码。在系统码中，码字 $c$ 的某 $k$ 个位置直接就是原始信息 $m$ 的比特，其余 $n-k$ 个位置是根据信息位计算出来的**校验位 (parity bits)** $p$。
        例如 $c = \begin{pmatrix} m \\ p \end{pmatrix}$ (信息位在前，校验位在后)。

    *   **系统码的生成矩阵 $G_{sys}$ 与校验矩阵 $H_{std}$ 的标准形式**:
        若要实现系统码 $c = \begin{pmatrix} m \\ p \end{pmatrix}$，生成矩阵 $G$ 可以具有如下标准形式：
        板书: $$ G_{n \times k} = \begin{pmatrix} I_k \\ P_{(n-k) \times k} \end{pmatrix} $$
        其中 $I_k$ 是 $k \times k$ 的单位矩阵，$P$ 是一个 $(n-k) \times k$ 的矩阵。
        编码时 $c = Gm = \begin{pmatrix} I_k \\ P \end{pmatrix} m = \begin{pmatrix} m \\ Pm \end{pmatrix}$。此时，校验位 $p = Pm$。

        对应的校验矩阵 $H$ (在适当的列置换和行变换后，使其与 $G_{sys}$ 的信息位和校验位对齐) 可以写成标准形式：
        板书: $$ H_{(n-k) \times n} = [P_{(n-k) \times k} | I_{n-k}] $$
        验证 $HG=\mathbf{0}$ (在 $GF(2)$ 中，加法即异或，故 $A+A=\mathbf{0}$):
        $$ HG = [P | I_{n-k}] \begin{pmatrix} I_k \\ P \end{pmatrix} = P \cdot I_k + I_{n-k} \cdot P = P + P = \mathbf{0} $$
        对于 $(7,4)$ 汉明码，$k=4, n-k=3$。
        $G_{7 \times 4} = \begin{pmatrix} I_4 \\ P_{3 \times 4} \end{pmatrix}$ 和 $H_{3 \times 7} = [P_{3 \times 4} | I_3]$。
        我们可以通过对原始的 $H$ 矩阵进行列变换和行变换，将其变为 $H' = [P' | I_3]$ 的形式，然后 $G_{sys} = \begin{pmatrix} I_4 \\ P' \end{pmatrix}$ 就是一个可以生成系统码的生成矩阵。(具体 $P'$ 的元素取决于如何选择信息位、校验位以及如何排列它们以匹配给定的 $H$)

    *   **编码过程总结**:
        1.  获取信息向量 $m$ ($k \times 1$)。
        2.  通过预先确定的生成矩阵 $G_{n \times k}$ (通常为系统形式) 计算码字 $c = Gm$。

---

**III. 线性码的一般参数与构造**

1.  **线性码参数 $[n, k, d]$ (源自 Part 3 笔记)**
    *   一个线性码通常用三个参数 $[n, k, d]$ 来描述。
        板书: `Linear Code [n, k, d]`
        *   $n$: 码长 (length of the codeword)。
        *   $k$: 码的维数 (dimension)，即独立信息位的数量。线性码是 $\{0,1\}^n$ 的一个 $k$ 维子空间。
        *   $d$: 码的最小汉明距离 (minimum Hamming distance)，通常记为 $d_{min}$。
    *   码字数量为 $2^k$ 个。
    *   例如，$(7,4)$ 汉明码可以表示为 `Hamming (7,4,3)`。

2.  **非线性码参数 $(n, M, d)$ (源自 Part 3 笔记)**
    *   非线性码通常用 $(n, M, d)$ 表示。
        板书: `Nonlinear Code (n, M, d)`
        *   $n$: 码长 (length)。
        *   $M$: 码字的数量 (#codewords)。对于非线性码，$M$ 不一定是 $2$ 的幂次。
        *   $d$: 最小汉明距离 (minimum Hamming distance)。

3.  **从已知码构造新码的方法 (源自 Part 3 笔记)**
    *   **缩短码 (Shortening)**:
        *   **过程**:
            1.  给定一个 $(n, M, d)$ 码 $C = \{c_1, c_2, \dots, c_M\}$。
            2.  选择码字中某个固定位置（例如第1位）具有相同比特值（例如0）的所有码字，形成一个子集 $C_0 = \{c \in C \mid c_1 = 0\}$。设 $|C_0| = M_0$。
            3.  从 $C_0$ 中的每个码字中删除这个固定的第1位。
        *   **得到的新码 $C'$ 的参数**: $(n-1, M_0, d')$
            *   新码长为 $n-1$。
            *   新码字数量为 $M_0$。对于线性码，如果该码包含全零码字，并且选择的位置不是所有码字都相同的（即存在码字在该位置为1），则 $M_0 = M/2$ (如果码空间在该位置投影到 $\{0,1\}$ 上是满的)。
            *   新最小距离 $d' \ge d$。这是因为删除一位不会减少原来已满足距离要求的码字之间的距离；如果两个码字在被删除位上相同，则距离不变；如果不同，则距离减1，但我们只取了在固定位上相同的码字。
        板书: `Shortening: Given $(n, M, d)$ code $C$`
               `$C_i = (0 | c'_i)$`
               `New code: $(n-1, M_0, d')$ where $d' \ge d$.`

    *   **扩展码 (Extending)**:
        *   **问题 (见思考题部分)**: 如何将 Hamming $(7,4,3)$ 码扩展成一个 $(8,4,4)$ 码？
        *   **思路**: 给原码的每个码字追加一个比特（通常是**总体校验位 (overall parity check bit)**），使得新码的最小距离增加。

---

**IV. 总结**

本节课我们深入学习了 $(7,4)$ 汉明码的特性，包括其作为完美线性码的定义，以及基于校验矩阵 $H$ 的高效解码（利用校验和 $S=Hx$）和基于生成矩阵 $G$ 的高效编码（利用 $c=Gm$ 和系统码形式）。我们还了解了线性码和非线性码的一般参数表示，并探讨了两种基本的码构造方法：缩短码和扩展码。这些内容为理解更高级的纠错码理论和实际应用打下了坚实的基础。

---

**V. 思考与讨论/习题**

1.  **问题：扩展汉明码 (源自 Part 3 笔记)**
    如何将 Hamming $(7,4,3)$ 码通过增加一位校验位，构造成一个 $(8,4,4)$ 的扩展汉明码？
    板书: `Hamming (7,4,3) $\xrightarrow{?}$ (8,4,4)`

    **解答**:
    *   **方法**: 为 Hamming $(7,4,3)$ 码中的每个7比特码字 $c$ 追加一个**总体校验位 (overall parity check bit)** $p$。这个校验位 $p$ 的选择使得新的8比特码字 $c' = (c_1, c_2, \dots, c_7, p)$ 的总汉明重量 $w_H(c')$ 为偶数。
        *   如果 $w_H(c)$ 是奇数，则 $p=1$。
        *   如果 $w_H(c)$ 是偶数，则 $p=0$。
        即 $p = \sum_{i=1}^7 c_i \pmod 2$。

    *   **参数变化**:
        *   **码长 $n'$**: 从 $n=7$ 增加到 $n'=8$。
        *   **维数 $k'$**: 原始信息仍然是4比特，增加的校验位是根据信息位（间接通过原7位码字）计算出来的，不增加新的自由度。所以维数 $k'$ 仍然是 $k=4$。码字数量仍为 $2^4=16$。

    *   **最小距离 $d'_{min}$ 分析**:
        Hamming $(7,4,3)$ 码的码字重量分布为：
        *   重量0: 1个 (全零码字)
        *   重量3: 7个
        *   重量4: 7个
        *   重量7: 1个 (全一码字，仅当 $H\mathbf{1}^T = \mathbf{0}$ 时存在，对于标准Hamming码是成立的)

        扩展后，新码字的重量将是：
        *   原重量0 (偶) $\rightarrow p=0 \rightarrow$ 新重量0 (偶)
        *   原重量3 (奇) $\rightarrow p=1 \rightarrow$ 新重量4 (偶)
        *   原重量4 (偶) $\rightarrow p=0 \rightarrow$ 新重量4 (偶)
        *   原重量7 (奇) $\rightarrow p=1 \rightarrow$ 新重量8 (偶)
        所有新码字的重量都为偶数。新码的最小非零重量是4。
        由于扩展后的码仍然是线性码（全零码字扩展后仍是全零；两个扩展码字相加，其信息部分是原码字相加，校验部分也是原校验位相加，保持偶重性），其最小距离 $d'_{min}$ 等于最小非零码字重量，即 $d'_{min}=4$。

        另一种分析距离的方法：
        考虑任意两个不同的原码字 $c_a, c_b \in C_{(7,4,3)}$，以及它们对应的扩展码字 $c'_a=(c_a, p_a)$ 和 $c'_b=(c_b, p_b)$。
        *   如果 $d_H(c_a, c_b)$ 是奇数（例如3, 5, 7）：
            这意味着 $w_H(c_a \oplus c_b)$ 是奇数。由于 $c_a \oplus c_b$ 也是一个（可能非零的）原码字，它的重量奇偶性决定了 $w_H(c_a)$ 和 $w_H(c_b)$ 的奇偶性关系。
            如果 $w_H(c_a)$ 和 $w_H(c_b)$ 奇偶性不同 (e.g., $w_H(c_a)$奇, $w_H(c_b)$偶)，则 $p_a=1, p_b=0$ (或反之)，所以 $p_a \ne p_b$。
            $d_H(c'_a, c'_b) = d_H(c_a, c_b) + d_H(p_a,p_b) = d_H(c_a, c_b) + 1$。
            所以，原距离为3的会变成距离4。
        *   如果 $d_H(c_a, c_b)$ 是偶数（例如4, 6）：
            如果 $w_H(c_a)$ 和 $w_H(c_b)$ 奇偶性相同 (e.g., $w_H(c_a)$奇, $w_H(c_b)$奇)，则 $p_a=1, p_b=1$ (或都为0)，所以 $p_a = p_b$。
            $d_H(c'_a, c'_b) = d_H(c_a, c_b) + d_H(p_a,p_b) = d_H(c_a, c_b) + 0 = d_H(c_a, c_b)$。
            所以，原距离为4的仍然是距离4。

        由于原最小距离是3（奇数），扩展后所有原距离为3的码字对，新距离都变为 $3+1=4$。原距离为4（偶数）的码字对，新距离仍为4。因此，新码的最小距离 $d'_{min} = 4$。

    *   **结论**: 通过增加一位总体校验位，Hamming $(7,4,3)$ 码可以被扩展为一个 $(8,4,4)$ 码，称为**扩展汉明码 (Extended Hamming Code)**。这个码可以纠正1位错误并检测2位错误（因为 $d_{min}=4 \implies t_{correct}=1, t_{detect}=d_{min}-1=3$, 但通常说能检 $d_{min}-1$ 个错，或纠 $t$ 检 $t+1$ 若 $d_{min} = 2t+2$）。

2.  **思考：从 $H$ 构造系统码的 $G$**
    对于笔记中给出的 $(7,4)$ 汉明码的校验矩阵 $H = \begin{pmatrix} 0 & 0 & 0 & 1 & 1 & 1 & 1 \\ 0 & 1 & 1 & 0 & 0 & 1 & 1 \\ 1 & 0 & 1 & 0 & 1 & 0 & 1 \end{pmatrix}$。
    如果希望构造一个系统码 $c = (m_1 m_2 m_3 m_4 | p_1 p_2 p_3)$，即信息位是前4位，校验位是后3位。如何找到对应的生成矩阵 $G_{sys} = \begin{pmatrix} I_4 \\ P_{3 \times 4} \end{pmatrix}$？
    (提示: 需要将 $H$ 通过列变换和行变换（如果需要）转换成标准形式 $H_{std} = [P | I_3]$，然后 $G_{sys}$ 中的 $P$ 部分就从 $H_{std}$ 中得到。或者直接求解 $Hx=0$ 的基，并将其转换为系统形式。)